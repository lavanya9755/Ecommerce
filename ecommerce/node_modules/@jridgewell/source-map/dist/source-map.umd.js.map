{"version":3,"file":"source-map.umd.js","sources":["../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs","../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs","../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs","../node_modules/@jridgewell/set-array/dist/set-array.mjs","../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs","../../src/source-map.ts"],"sourcesContent":["const comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\nfor (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n}\n// Provide a fallback for older environments.\nconst td = typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n        ? {\n            decode(buf) {\n                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                return out.toString();\n            },\n        }\n        : {\n            decode(buf) {\n                let out = '';\n                for (let i = 0; i < buf.length; i++) {\n                    out += String.fromCharCode(buf[i]);\n                }\n                return out;\n            },\n        };\nfunction decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let index = 0;\n    do {\n        const semi = indexOf(mappings, index);\n        const line = [];\n        let sorted = true;\n        let lastCol = 0;\n        state[0] = 0;\n        for (let i = index; i < semi; i++) {\n            let seg;\n            i = decodeInteger(mappings, i, state, 0); // genColumn\n            const col = state[0];\n            if (col < lastCol)\n                sorted = false;\n            lastCol = col;\n            if (hasMoreVlq(mappings, i, semi)) {\n                i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                i = decodeInteger(mappings, i, state, 2); // sourceLine\n                i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 4); // namesIndex\n                    seg = [col, state[1], state[2], state[3], state[4]];\n                }\n                else {\n                    seg = [col, state[1], state[2], state[3]];\n                }\n            }\n            else {\n                seg = [col];\n            }\n            line.push(seg);\n        }\n        if (!sorted)\n            sort(line);\n        decoded.push(line);\n        index = semi + 1;\n    } while (index <= mappings.length);\n    return decoded;\n}\nfunction indexOf(mappings, index) {\n    const idx = mappings.indexOf(';', index);\n    return idx === -1 ? mappings.length : idx;\n}\nfunction decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n        const c = mappings.charCodeAt(pos++);\n        integer = charToInt[c];\n        value |= (integer & 31) << shift;\n        shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n        value = -0x80000000 | -value;\n    }\n    state[j] += value;\n    return pos;\n}\nfunction hasMoreVlq(mappings, i, length) {\n    if (i >= length)\n        return false;\n    return mappings.charCodeAt(i) !== comma;\n}\nfunction sort(line) {\n    line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[0] - b[0];\n}\nfunction encode(decoded) {\n    const state = new Int32Array(5);\n    const bufLength = 1024 * 16;\n    const subLength = bufLength - 36;\n    const buf = new Uint8Array(bufLength);\n    const sub = buf.subarray(0, subLength);\n    let pos = 0;\n    let out = '';\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        if (i > 0) {\n            if (pos === bufLength) {\n                out += td.decode(buf);\n                pos = 0;\n            }\n            buf[pos++] = semicolon;\n        }\n        if (line.length === 0)\n            continue;\n        state[0] = 0;\n        for (let j = 0; j < line.length; j++) {\n            const segment = line[j];\n            // We can push up to 5 ints, each int can take at most 7 chars, and we\n            // may push a comma.\n            if (pos > subLength) {\n                out += td.decode(sub);\n                buf.copyWithin(0, subLength, pos);\n                pos -= subLength;\n            }\n            if (j > 0)\n                buf[pos++] = comma;\n            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n            if (segment.length === 1)\n                continue;\n            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n            pos = encodeInt